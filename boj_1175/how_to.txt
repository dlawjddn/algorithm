문제
어제 선물을 모두 포장한 민식이는 이제 선물을 배달하려고 한다. 민식이가 선물을 배달할 곳은 이 문제를 읽는 사람들이 앉아 있는 교실이다. 교실은 직사각형모양이고, 모두 같은 크기의 정사각형 블록으로 나누어져 있다.

입력으로 교실의 지도가 주어진다. 각각의 정사각형 블록은 다음과 같이 4가지 종류가 있다.

S: 지금 민식이가 있는 곳이다. 이곳이 민식이가 배달을 시작하는 곳이고 1개만 있다.
C: 민식이가 반드시 선물을 배달해야 하는 곳이다. 이러한 블록은 정확하게 2개 있다.
#: 민식이가 갈 수 없는 곳이다.
.: 민식이가 자유롭게 지나갈 수 있는 곳이다.
민식이가 한 블록 동서남북으로 이동하는데는 1분이 걸린다. 민식이는 네가지 방향 중 하나로 이동할 수 있으며, 교실을 벗어날 수 없다. 민식이가 선물을 배달해야 하는 곳에 들어갈 때, 민식이는 그 곳에 있는 사람 모두에게 선물을 전달해야 한다. 이 상황은 동시에 일어나며, 추가적인 시간이 소요되지 않는다.

민식이는 어느 누구도 자신을 보지 않았으면 하기 때문에, 멈추지 않고 매 시간마다 방향을 바꿔야 한다. 이 말은 같은 방향으로 두 번 연속으로 이동할 수 없다는 말이다. 민식이가 선물을 모두 배달하는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.

입력
첫째 줄에 교실의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 교실의 지도가 주어진다.

출력
첫째 줄에 민식이가 선물을 모두 배달하는데 걸리는 시간의 최솟값을 출력한다. 만약 불가능 할 때는 -1을 출력한다.

주관적인 문제 느낌:

처음에 이 문제를 보고 음.. 굳이 위치파악을 할 필요없이 먼저 찾은 애를 처음으로 두고 그 다음 것을 찾고 그 횟수를 리턴하면 되겠구나 싶었다. 실제로 그렇게 했고 많은 경우에 정답을 받았다. 

하지만 마지막 예제에서 결과는 나오지만 정답은 안 나왔다. 그래서 생각을 해봤는데 이 방법이 틀릴 수도 있겠다 라는 생각을 하게 되었다. 

왜냐하면 내가 처음에 생각한 방법은 1가지의 경우만을 생각하는데 그 경우는
1. 시작점으로 가까운 곳을 먼저 방문
2. 그 곳에서 다음 목적지까지의 거리  의 방법만 확인한다

하지만 이 문제의 경우 두가지의 경우가 나오는데(두개의 C를 c와 c'으로 생각을 한다면)

1. S -> c -> c'
2. S-> c' -> c 의 두 가지 경우가 생긴다. 사실 어떤 경우던 가장 가깝게 방문할 수 있는 경로가 있다면 어디에 두던 갈 수 있지만 뭔가 문제점이 있었던 것 같다.

이제서야 생각이 드는건데 내가 처음에 생각한 방법은 하나를 찾고 방문여부를 0으로 초기화를 했는데 그 방법에서 뭔가 불필요한 횟수가 추가되는 상황이 생기는 것 같다. 아직까지도 이거구나 싶은 확실한 방법은 잘 모르겠다.

그래서 그냥 모든 경우를 생각하면서 두개 모두를 방문할 때의 최소 방문횟수를 출력하게 했더니 맞았다. 
구현은 어렵지 않았다. 그래프 문제에서 많이 찾아볼 수 있는 대표적인 문제 중 하나인 것 같다. 

1 failed, 1 success
