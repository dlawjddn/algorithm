문제 설명:
맵이 주어지고 맵은 빈 공간, 물고기(크기), 아기 상어 이렇게 3가지로 구성 되어있다.
아기 상어가 본인의 크기보다 작은 물고기들을 먹는데, 만약 이동 할 때 같은 크기의 물고기는 이동할 수 있지만 먹지는 못한다.
또한, 아기 상어의 크기가 n일 때, 물고기를 n개 만큼 먹어야 n+1로 크기가 늘어난다.
아기 상어는 상하좌우로 이동하며, 한 칸 이동할 때 마다 1초의 시간이 걸린다.
이 때 아기 상어가 스스로의 힘으로 먹을 수 있는 모든 물고기를 먹을 때, 걸리는 시간을 출력한다.
가장 가까운 거리에 있는 물고기를 우선으로 먹는데, 가장 가까운 거리의 물고기가 여러 마리 일 때, 
행이 작은 물고기, 행도 같다면 열이 작은 물고기 부터 먹는다.
주관적인 문제 느낌:
1. 처음 구현은 bfs를 사용해서 구현했다. bfs를 구현할 때, 물고기를 선택하는 경우를 확인하기 위해서
이동 순서를 좌 상 하 우로 주고 가장 먼저 찾은 물고기를 리턴해서 그걸 먹는 방법으로 구현했다.
이 방법의 문제는 순서에 의존하다보니 올바른 값을 찾지 못한 것 같다. (예제 4번이 그랬다.)
2. 방문했던 곳의 map[][]을 0으로 초기화 해야 최소 이동시간을 정확히 찾을 수 있는데(처음 위치의 map[][]의 값이 9이기 때문에 잘 못 고를 수 있음)
그 부분에 대해서 초기화를 해서 정확도를 올렸다.
3. 그래도 안 풀려서 이유를 질문 게시판에서 여러 반례를 찾아봤는데, 반례가 문제가 아니라 그냥 bfs로 내가 먹을 물고기를 고르는게 잘못 된 부분이었다.
이동시간과 map을 사용해서 해당 최소 이동시간을 구하는게 정확한 방법이었다...
그렇게 구현을 하니 맞았다.

오랜만에 알고리즘 재밌고 집중해서 풀었던 것 같다. 재밌었다.

1 fail 1 success
