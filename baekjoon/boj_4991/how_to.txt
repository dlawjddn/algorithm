문제 설명: 
맵이 주어지고 맵은 청소기의 초기 위치, 청소해야할 위치, 벽, 빈공간 4가지에 대한 정보를 준다.
이 정보를 가지고 청소해야할 곳에 대해서 모두 청소를 할 때, 최소 이동회수를 구하는 문제이며 청소를 못하는 구역이 생긴다면 -1을 출력한다.

주관적인 문제 느낌:
굉장히 까다로웠다. 처음에는 일반적인 bfs로 구현을 하면 되겠거니 싶었는데,
내가 청소하는 구역을 선택하는 순서에 따라서 답이 변할 수도 있다는 반례를 보고 코드를 갈아 엎었다 ㅠㅠ..
청소해야할 구역이 최대 10개까지만 주어진다고 하니, 순열로 모든 경우에 대한 경우의 수를 구하고, 모든 경우에 대해서 최소 이동횟수를 구하면 된다.
그 경우를 구할 때 하나라도 방문하지 못한다면 바로 -1을 출력하면 된다.
이 문제를 해결하면서 플래그를 어뛓게 써야하는지, 벡터에 대한 섬세한 사용법을 다시 한번 생각하게 되었다.
까다로웠지만 많은 고민을 하게 된 문제이고, 이 문제를 해결하기 위해서 c++에서 순열을 어떻게 다루는지에 대해서도 알게 되었다.
생각보다 까다로웠지만 그만큼 재미도 있었던 문제라고 기억이 날 것 같다.

3 wrong 4 timeover 1 error 1 success
